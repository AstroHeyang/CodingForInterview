## 题目描述
**奇虎360 2017年春招**

A、B两伙马贼意外地在一片沙漠中发现了一处金矿，双方都想独占金矿，但各自的实力都不足以吞下对方，
经过谈判后，双方同意用一个公平的方式来处理这片金矿。处理的规则如下：他们把整个金矿分成n段，由A、
B开始轮流从最左端或最右端占据一段，直到分完为止。 马贼A想提前知道他们能分到多少金子，因此请你帮
忙计算他们最后各自拥有多少金子?（两伙马贼均会采取对己方有利的策略）

**输入**

测试数据包含多组输入数据。输入数据的第一行为一个正整数T(T<=20)，表示测试数据的组数。然后是T组测试数据，
每组测试数据的第一行包含一个整数n，下一行包含n个数（n <= 500 ），表示每段金矿的含金量，保证其数值大小
不超过1000。

**样例输入**

2 

6

4 7 2 9 5 2

10

140 649 340 982 105 86 56 610 340 879

**输出**

对于每一组测试数据，输出一行"Case #id: sc1 sc2"，表示第id组数据时马贼A分到金子数量为sc1，马贼B分到金子数量为sc2。详见样例。

**样例输出**

Case #1: 18 11

Case #2: 3206 981

## 解题思路
A想获得更多的金子，可以转化为在每次选择后使得B获得的金子数更少。
使用动态规划，具体如下：
1. 状态定义：假设数组G代表已划分好的金子的分布，dp[i][j]则是当剩下的金子分布为G[i:j+1]时，A能获得的最大金子数；
2. 转移方程：A可以从左右两端其中一端取金子，按照上述思路，A获取金子后，需使得B能获取金子数最少，即
dp[i][j] = sum(G[i:j+1]) - min(dp[i+1][j], dp[i][j-1]),
其中sum(G[i:j+1])代表当前剩余总金子数，dp[i+1][j]和dp[i][j-1]分别为A从左边和右边取金后B能获取的最大金字数。
3. 初始值：dp[i][i] = G[i]。

**Tricks**
1. 初始化二维数组dp时，需警惕浅拷贝的风险。
2. 给dp数组赋值时，需要注意循环顺序，例如,
第一层循环：
dp[0][1] = sum(G[0:2]) - min(dp[1][1], dp[0][0]), 之后计算dp[1][2], dp[2][3], ..., dp[n-1][n]
第二层循环：
计算dp[0][2],...dp[n-2][n]; dp[0:3],...,dp[n-3][n]; ...;直到dp[0][n]。
最后返回dp[0][n], 这里n+1为G中元素数量。

## 时间复杂度
O(n^2)， 空间复杂度O(n^2)

